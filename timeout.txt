// ********* app.component.ts *********
import { Component, inject, HostListener } from '@angular/core';
import { HeaderComponent } from './shared/components/header-footer/header/header.component';
import { FooterComponent } from './shared/components/header-footer/footer/footer.component';
import { Router, RouterModule, NavigationEnd} from '@angular/router';
import { AnalyticsService } from 'src/app/shared/services/analytics.service';
import { AuthenticationService } from './shared/services/authentication.service';
import { CommonModule } from '@angular/common';
import { ConfigService } from './shared/services/config.service';
import { TimeoutService } from './shared/services/timeout.service';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [
    HeaderComponent,
    FooterComponent,
    RouterModule,
    CommonModule,
  ],
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent {
  private readonly authService = inject(AuthenticationService);
  private readonly router = inject(Router);
  private readonly adobeService = inject(AnalyticsService);
  private readonly configService = inject(ConfigService);
  private readonly timeoutService = inject(TimeoutService);

  constructor() {
    this.router.events.subscribe(event => {
      if (event instanceof NavigationEnd) {
        this.adobeService.postPageTrack();
      }
    });
  }

  @HostListener('click', ['$event'])
  onClick(event: Event) {
    this.adobeService.postLinkTrackEvent(event.target as HTMLElement);
  }  

  ngOnInit(): void {
    if (this.authService.oldHsidTokenExists) {
      console.log('Reinitializing HSID token');
      this.authService.reInitializeHsidToken();
    }
    
    this.timeoutService.initialize(this.configService.settings.timeoutSettings);     
  }

  public isAuthenticated(): boolean {
    return this.authService.isAuthenticated();
  }
}

// ********* timeout.service.ts *********
import { Injectable, OnDestroy, inject } from '@angular/core';
import { Router } from '@angular/router';
import { MatDialog, MatDialogRef } from '@angular/material/dialog';
import { BehaviorSubject, Subject, timer, fromEvent, merge, Subscription } from 'rxjs';
import { debounceTime, takeUntil } from 'rxjs/operators';
import { TimeoutConfig } from '../models/timeout-config.model';
import { TimeoutDialogComponent } from '../components/timeout/timeout-dialog.component';
import { AuthenticationService } from './authentication.service';

@Injectable({
  providedIn: 'root'
})
export class TimeoutService implements OnDestroy {
  private config!: TimeoutConfig;
  private destroy$ = new Subject<void>();
  private userActivity!: Subscription;
  private idleTimer!: Subscription;
  private sessionTimer!: Subscription;
  private countdownValue = new BehaviorSubject<number>(0);
  private currentDialog: MatDialogRef<TimeoutDialogComponent> | null = null;
  countdownValue$ = this.countdownValue.asObservable();

  private readonly authService = inject(AuthenticationService);
  private readonly router = inject(Router);

  constructor(    
    private dialog: MatDialog
  ) {}
  
  public initialize(config: TimeoutConfig): void {
    this.config = config;
    this.initializeIdleTimeout();
    this.initializeSessionTimeout();
  }

  private initializeIdleTimeout(): void {
    const activity$ = merge(
      fromEvent(document, 'mousemove'),
      fromEvent(document, 'keydown'),
      fromEvent(document, 'click'),
      fromEvent(document, 'wheel')
    ).pipe(
      debounceTime(500),
      takeUntil(this.destroy$)
    );
    
    this.userActivity = activity$.subscribe(() => {
      if (!this.currentDialog?.componentInstance?.isIdleDialog) {
        this.resetIdleTimer();
      }
    });
    this.resetIdleTimer();
  }

  private initializeSessionTimeout(): void {
    this.sessionTimer = timer(this.config.sessionTimeout.timeoutMinutes * 60 * 1000).subscribe(() => {

      if (this.authService.isHsidRefreshTokenEnabled()) {
        console.log('HSID token refresh enabled; not showing session timeout dialog');
        return;
      }
        
      console.log('HSID token refresh not enabled.');

      if (this.currentDialog) {
        this.currentDialog.close();
      }

      this.currentDialog = this.dialog.open(TimeoutDialogComponent, {
        disableClose: true,
        width: '400px',
        data: {
          title: this.config.sessionTimeout.title,
          message1: this.config.sessionTimeout.message1,
          message2: this.config.sessionTimeout.message2,
          buttonText: this.config.sessionTimeout.buttonText,
          showCountdown: false,
          isIdleDialog: false
        } 
      });

      this.currentDialog.afterClosed().subscribe(() => {        
        this.currentDialog = null;
        this.logout();
      });
    });
  }

  private resetIdleTimer(): void {
    if (this.idleTimer) {
      this.idleTimer.unsubscribe();
    }
    this.idleTimer = timer(this.config.idleTimeout.timeoutMinutes * 60 * 1000).subscribe(() => {
      if (!this.currentDialog) {
        this.startLogoutCountdown();
      }
    });
  }

  private startLogoutCountdown(): void {
    this.countdownValue.next(this.config.idleTimeout.logoutCountdownSeconds);
    this.currentDialog = this.dialog.open(TimeoutDialogComponent, {
      disableClose: true,
      width: '400px',
      data: {
        title: this.config.idleTimeout.title,
        message1: this.config.idleTimeout.message1,
        message2: this.config.idleTimeout.message2,
        buttonText: this.config.idleTimeout.buttonText,
        countdown: this.countdownValue$,
        showCountdown: true,
        isIdleDialog: true
      }
    });

    const countdown = timer(0, 1000).subscribe(() => {
      const currentValue = this.countdownValue.value;
      if (currentValue <= 0) {
        countdown.unsubscribe();
        if (this.currentDialog) {
          this.currentDialog.close();
        }
        this.logout();
      } else {
        this.countdownValue.next(currentValue - 1);
      }
    });

    this.currentDialog.afterClosed().subscribe(() => {
      countdown.unsubscribe();
      const dialogInstance = this.currentDialog?.componentInstance;
      if (dialogInstance && dialogInstance.isIdleDialog) {
        this.currentDialog = null;
        this.resetIdleTimer();
      }
    });
  }


  private logout(): void {    
    this.router.navigate(['/signout']);
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
    if (this.userActivity) this.userActivity.unsubscribe();
    if (this.idleTimer) this.idleTimer.unsubscribe();
    if (this.sessionTimer) this.sessionTimer.unsubscribe();
    if (this.currentDialog) {
      this.currentDialog.close();
    }
  }
}

// ********* authentication.service.ts *********
import { Injectable, inject } from '@angular/core';
import { HsidAccessToken, HsidTokenResponse, OhidAccessToken, PartnerCenterUser, PartnerCenterUserPermissions, Token, UserIdentity } from '../models/token.interfaces';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, map, of } from 'rxjs';
import { ConfigService } from './config.service';
import { environment } from 'src/environments/environment';
import { CustomCookieService } from './custom-cookie.service';
import { Router } from '@angular/router';

@Injectable({
  providedIn: 'root',
})
export class AuthenticationService {
  private readonly cookieService = inject(CustomCookieService);
  private readonly configService = inject(ConfigService);
  private readonly http = inject(HttpClient);
  private readonly router = inject(Router);

  private tokenKey!: string;
  private myaccountApiUrlV4!: string;
  private internalKey!: string;
  private hsidTokenRefreshSchedule: any = null;  
  private isRefrehingHsidToken: boolean = false;

  public init(): Promise<void> {
    this.tokenKey = this.configService.settings.tokenKey;
    this.myaccountApiUrlV4 = this.configService.settings.myaccountApiUrlV4;
    this.internalKey = this.configService.settings.internalKey;
    return Promise.resolve();
  }  

  public get PartnerCenterUserPermissions(): PartnerCenterUserPermissions | null {
    const partnerCenterUser = this.getPartnerCenterUser();
    return partnerCenterUser?.Permissions || null;   
  }

  public setPartnerCenterUser(user: PartnerCenterUser) {
    this.cookieService.setCookie('partnerCenterUser', JSON.stringify(user));
  }

  public getPartnerCenterUser(): PartnerCenterUser | null {
    const userString = this.cookieService.getCookie('partnerCenterUser');
    if (userString) {
      return JSON.parse(userString);
    }
    return null;
  }

  public isPartnerCenterUser(): boolean {
    const partnerCenterUser = this.getPartnerCenterUser();
    return partnerCenterUser !== null;
  }

  public isHsidRefreshTokenEnabled(): boolean {
    return (this.hsidTokenRefreshSchedule !== null);
  }

  public get oldHsidTokenExists(): boolean {
    const tokenString = this.cookieService.getCookie(this.tokenKey);

    if (tokenString) {
      const token = JSON.parse(tokenString);

      if (token && token.object.type === 'hsid' && !this.isHsidRefreshTokenEnabled()) 
        return true;
    }    
    return false;
  }
  
  public getHsidTokenAndInsuredId(authCode: string, state: string): Observable<{ hsidToken: HsidAccessToken, insuredId: number, isCsr: boolean }> {
    const apiUrl = `${this.myaccountApiUrlV4}/utility/insuredidlookup?code=${authCode}&isMobile=false&state=${state}`;
    return this.http.get<HsidTokenResponse>(apiUrl).pipe(
      map((response: HsidTokenResponse) => {
        const hsidToken = response.Token;
        const insuredId = response.InsuredId;
        const isCsr = response.IsCsr;

        const refreshIntervalSeconds = response.Token.expires_in - this.configService.settings.hsidRefreshTokenSettings.secondsBeforeTokenExpiry;
        this.hsidTokenRefreshSchedule = setTimeout(() => this.refreshHsidToken(insuredId, isCsr), refreshIntervalSeconds * 1000);
        console.log(`Successful HSID login. Token refresh will occur in ${refreshIntervalSeconds} seconds`);

        return { hsidToken, insuredId, isCsr };
      }),
    );
  }

  private ensureCurrentHsidTokenIsValid(): boolean {
    console.log('Ensuring current HSID token is valid');

    let isValid = false;

    try {
      const tokenString = this.cookieService.getCookie(this.tokenKey);

      if (tokenString) {
        const token = JSON.parse(tokenString);
  
        const hashString = atob(token.hash);
        const accessToken = JSON.parse(hashString) as HsidAccessToken;
        const expires_in_seconds = accessToken.expires_in;
        const creationTime = token.object.creationTime;
        const isExpired = (new Date().getTime() - creationTime) / 1000 > expires_in_seconds;

        isValid = !isExpired;
      }
    }
    catch (e) {
      console.log('Error checking for current HSID token validity', e);      
    }  
    
    if (!isValid) {
      console.log('Current HSID token is invalid; redirecting to signout page');
      this.router.navigate(['/signout']);
      return false;
    }
    else {
      console.log('Verified current HSID token is valid');
      return true;
    }
  }

  private refreshHsidToken(insuredId: number, isCsr: boolean): void {
    if (this.isRefrehingHsidToken) return;

    if (!this.ensureCurrentHsidTokenIsValid()) return;
    
    console.log('Refreshing HSID token');
    
    const apiUrl = `${this.myaccountApiUrlV4}/utility/HsidRefreshToken`;
    this.isRefrehingHsidToken = true;

    if (this.hsidTokenRefreshSchedule) {
      clearTimeout(this.hsidTokenRefreshSchedule);   
      this.hsidTokenRefreshSchedule = null;
    }
    
    this.http.get<HsidAccessToken>(apiUrl, {headers: new HttpHeaders({ 'X-Skip-Error-Check': 'true' })}).subscribe({
      next: (response: HsidAccessToken) => {
        this.isRefrehingHsidToken = false;        
        this.cookieService.setAccessTokenCookie(
          { 
            hash: btoa(JSON.stringify(response)),                  
            object: { 
              type: 'hsid',
              InsuredId: insuredId, 
              role: isCsr ? 'CSW' : '',              
              creationTime: new Date().getTime()
            } 
          }); 
          
          const refreshIntervalSeconds = response.expires_in - this.configService.settings.hsidRefreshTokenSettings.secondsBeforeTokenExpiry;
          this.hsidTokenRefreshSchedule = setTimeout(() => this.refreshHsidToken(insuredId, isCsr), refreshIntervalSeconds * 1000);
          console.log(`HSID token refresh successful; next refresh in ${refreshIntervalSeconds} seconds`);
      },
      error: (e) => {
        this.isRefrehingHsidToken = false;
        const refreshIntervalSeconds = this.configService.settings.hsidRefreshTokenSettings.retryIntervalSeconds;
        setTimeout(() => this.refreshHsidToken(insuredId, isCsr), refreshIntervalSeconds * 1000);
        console.error(`There was an error retreiving HSID refresh token; next retry in ${refreshIntervalSeconds} seconds`, e);
      },
    });
  }

  public reInitializeHsidToken(): void {
    const identity = this.getUserIdentity();
    if (identity) {
      this.refreshHsidToken(identity.insuredId, identity.isCsr);
    }
  }

  public getPartnerCenterTokenAndInsuredId(role: string, accessToken: string): Observable<OhidAccessToken> {
    const headers = new HttpHeaders({ 'Authorization': `Bearer ${accessToken}` });
    const apiUrl = `${this.configService.settings.partnerCenterSecurityUrl}/Account/GetMyAccountInfo?requestString=${role}`;
    return this.http.get<OhidAccessToken[]>(apiUrl, { headers }).pipe(
      map(response => response[0])
    );
  }

  public getCswTokenAndInsuredId(): Observable<{ secret: string }> {
    if (this.internalKey === '') {
      return of({ secret: '' });
    }

    const payload = { 
      'SecretKey': this.internalKey,
      'RequestDate': new Date().toDateString(),
    };
    const keySalt = btoa(JSON.stringify(payload));
    const breakpoint = Math.floor(Math.random() * keySalt.length) + 1;
    const key = keySalt.substring(0, breakpoint);
    const salt = keySalt.substring(breakpoint);
    const headers = new HttpHeaders({ 'Client': 'Premium' });
    return this.http.get<{ loadA: string, loadB: string }>(`${this.myaccountApiUrlV4}/utility/VaultLookup?key=${key}==&salt=${salt}=`, { headers }).pipe(
      map(response => {
        const rawData = response.loadA + response.loadB;
        const data = JSON.parse(atob(rawData)) as { ClientSecret: string };
        return { secret: data.ClientSecret };
      }),
    );
  }

  public getAccessToken(): string | null {
    const tokenString = this.cookieService.getCookie(this.tokenKey);
    if (!tokenString) {
      return null;
    }
    const token: Token = JSON.parse(tokenString);
    return token ? token.hash : null;
  }

  public getAccessRole(): string {
    const tokenString = this.cookieService.getCookie(this.tokenKey);
    if (!tokenString) {
      return '';
    }
    const token: Token = JSON.parse(tokenString);
    return token ? token.object.role : '';
  }

  public isAuthenticated(): boolean {
    // When running locally there is no HSID integration, so we return true
    if (!environment.production) {
      return true;
    } else {
      const accessToken = this.getAccessToken();
      return accessToken !== null;
    }
  }

  public getUserIdentity(): UserIdentity | null {
    // When running locally there is no HSID integration, so we return a dummy user identity
    if (!environment.production) {
      return { insuredId: 50410, isCsr: false };
    } else {
      const tokenString = this.cookieService.getCookie(this.tokenKey);
      if (!tokenString) {
        return null;
      }
      const token: Token = JSON.parse(tokenString);
      return token && token.object ? { insuredId: token.object.InsuredId, isCsr: token.object.role !== '' } : null;  
    }
  }

  public getIdToken(): string | null {
    const tokenString = this.cookieService.getCookie(this.tokenKey);
    if (!tokenString) {
      return null;
    }
    const token: Token = JSON.parse(tokenString);
    if (token && token.hash) {
      // convert token.hash from base64 to string
      const hashString = atob(token.hash);
      if (hashString) {
        try {
          const hash = JSON.parse(hashString) as HsidAccessToken;
          return hash.id_token;
        } catch {
          return null;
        }
      }
    }
    return null;
  }

  public setAccessToken(type: string, accessToken: string | HsidAccessToken | OhidAccessToken, insuredId: number, isCsw: boolean = false, isPC: boolean = false): void {
    const token: Token = {
      hash: typeof accessToken === 'string' ? btoa(accessToken) : btoa(JSON.stringify(accessToken)),
      object: {
        type: type,
        InsuredId: insuredId,
        role: isPC ? 'PartnerCenter' : (isCsw ? 'CSW' : ''),
        creationTime: new Date().getTime(),
      },
    };
    this.cookieService.setAccessTokenCookie(token);
  }
  
  public clearAccessToken(): void {
    this.cookieService.deleteAllCookies();

    if (this.hsidTokenRefreshSchedule) 
      clearTimeout(this.hsidTokenRefreshSchedule);
  }
}
